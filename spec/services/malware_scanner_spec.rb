require 'rails_helper'

RSpec.describe MalwareScanner do
  let(:provider) { create :provider }
  let(:file_path) { Rails.root.join('spec/fixtures/files/documents/hello_world.pdf') }
  let(:file_details) do
    {
      name: Faker::File.file_name,
      size: Faker::Number.number,
      content_type: Faker::File.mime_type,
      foo: 'bar'
    }.stringify_keys
  end
  let(:malware_scan_result) { MalwareScanResult.last }

  subject do
    described_class.call(
      file_path: file_path,
      uploader: provider,
      file_details: file_details
    )
  end

  describe '#call' do
    it 'creates a MalwareScanResult record' do
      expect { subject }.to change { MalwareScanResult.count }.by(1)
    end

    it 'records uploader and details of file' do
      subject
      expect(malware_scan_result.uploader).to eq(provider)
      expect(malware_scan_result.file_details).to eq(file_details)
    end

    it 'returns created MalwareScanResult record' do
      expect(subject).to be_a(MalwareScanResult)
      expect(subject.id).to eq(malware_scan_result.id)
    end

    context 'file is safe' do
      it 'sets virus_found to false' do
        expect(subject.virus_found?).to eq(false)
      end
    end

    context 'virus is found' do
      let(:file_path) { Rails.root.join('spec/fixtures/files/malware.doc') }

      it 'sets virus_found to true' do
        expect(subject.virus_found?).to eq(true)
      end
    end

    context 'scanner down' do
      let(:scan_result) { ["failed: No such file or directory. ERROR\n", '', double('process_status', exitstatus: 2, success?: false)] }
      before { allow(Open3).to receive(:capture3).and_return(scan_result) }

      it 'returns false' do
        expect(subject.scanner_working).to eq false
      end

      it 'notifies sentry' do
        expect(Sentry).to receive(:capture_message).with(/ClamdscanError, failed: No such file or directory. ERROR/)
        subject
      end
    end

    context 'scan_result' do
      let(:stub_stdout) { Faker::Lorem.sentence }
      let(:scan_result) { [stub_stdout, '', double('process_status', success?: true, exitstatus: 0)] }

      before { allow(Open3).to receive(:capture3).and_return(scan_result) }

      it 'returns and records the result of the scan' do
        expect(subject.scan_result).to eq(stub_stdout.strip)
        expect(malware_scan_result.scan_result).to eq(stub_stdout.strip)
      end
    end

    context 'not saving result' do
      subject { described_class.call(file_path: file_path, save_result: false) }

      it 'does not create a MalwareScanResult record' do
        expect { subject }.to_not change { MalwareScanResult.count }
      end

      it 'returns a MalwareScanResult object' do
        expect(subject).to be_a(MalwareScanResult)
      end
    end
  end
end
